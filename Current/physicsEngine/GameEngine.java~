package Files.Current.physicsEngine;

import java.awt.Canvas;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Toolkit;
import java.awt.geom.AffineTransform;
import java.awt.geom.*;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;

import java.util.ArrayList;
import javax.swing.JFrame;
import javax.swing.JPanel;

import java.awt.event.KeyEvent;
import java.awt.event.KeyAdapter;

public class GameEngine extends JPanel implements Pausable
{
  public static final int MAX_SPAWN = 20; //30
  public static final int X = 500;
  public static final int Y = 500;
  public static final float GRAVITY = .0000981f; //1500
  public static final float DRAG = 0.1f; //0.2
  public static final float BOUNCE = 1f; //0.5
  public final int UPDATE_RATE = 60;
  public static final String TITLE = "Mike's 2d Physics Engine greatly modified by Jason using code written by Hock-Chuan Chua";
  private static Graphics graphics;
  private static Graphics2D g2d;
//  private static AffineTransform at;
  public static ArrayList<Spawn> living = new ArrayList<Spawn>();
  public static ArrayList<ButtonObstacle> buttons = new ArrayList<ButtonObstacle>();
  public static ArrayList<Paddle> paddles = new ArrayList<Paddle>();
  public static ArrayList<ObstacleLine> lines = new ArrayList<ObstacleLine>();
  public static ArrayList<PseudoPaddle> pseudoPaddles = new ArrayList<PseudoPaddle>();
  public static boolean isRunning = true;
  private int fps;
  public static boolean paused = false;
  public static boolean terminated = false;
  public static int score = 0;
  public static int layout;
  MoveEngine moveEngine;
 public  HighScoreManager highscoreManager;
  
  public static final int EASY_LAYOUT = 0;
  public static final int MEDIUM_LAYOUT = 1;
  public static final int HARD_LAYOUT = 2;
  
  
  public GameEngine ()
  {
    // Create canvas for painting...
    //setIgnoreRepaint(true);
    setSize(X, Y);
    setBackground (Color.WHITE);
    // Add the canvas, and display.
    setVisible(true);
    // Set up the BufferStrategy for double buffering.
    setDoubleBuffered(true);
 moveEngine = new MoveEngine(this);
    // Objects needed for rendering...
    graphics = null;
    g2d = null;
    initialize();
    highscoreManager = new HighScoreManager();
  }
  
  public void initialize ()
  {
    //The ball
   living.add (new CircleSpawn (16,16,0,0,100));


    //walls
    lines.add (new ObstacleLine (0,0,0,550,Color.BLACK));
    lines.add (new ObstacleLine (396,0,396,550,Color.BLACK));
    lines.add (new ObstacleLine (0,0,400,0,Color.BLACK));
    
    //slopes to the paddle
    lines.add (new ObstacleLine (0,400,100,500,Color.BLACK));
    lines.add (new ObstacleLine (400,400,300,500,Color.BLACK));
    pseudoPaddles.add (new PseudoPaddle (150,500,100,Color.BLACK)); 
  }
  
  public void reset ()
  {
    living.clear ();
    buttons.clear();
    lines.clear();
    paddles.clear();
    pseudoPaddles.clear();
  }
  
  public void easyLayout ()
  {
    
   //Button
   buttons.add (new ButtonObstacle (50,200,15,1.1f,Color.BLACK));
   buttons.add (new ButtonObstacle (150,200,15,1.1f,Color.BLACK));
   buttons.add (new ButtonObstacle (250,200,15,1.1f,Color.BLACK));
   buttons.add (new ButtonObstacle (350,200,15,1.1f,Color.BLACK));
    layout = EASY_LAYOUT;

  }
  
  public void mediumLayout ()
  {
    //   Center obstacle
    lines.add (new BumperObstacleLine (100,200,300,200));
    lines.add (new ObstacleLine (100,200,200,300,Color.BLACK));
    lines.add (new ObstacleLine (200,300,300,200,Color.BLACK));
    layout = MEDIUM_LAYOUT;
  }
  
  public void hardLayout ()
  {
       buttons.add (new ButtonObstacle (200,200,30,1.1f,Color.BLACK));
       lines.add (new BumperObstacleLine (200,150,250,200));
  lines.add (new BumperObstacleLine (200,150,150,200));
  layout = HARD_LAYOUT;
  }
  
  public void setGameLayout (int layout)
  {
    reset ();
    initialize ();
    switch (layout){
      case EASY_LAYOUT : easyLayout();
      break;
      case MEDIUM_LAYOUT : mediumLayout ();
      break;
      case HARD_LAYOUT : hardLayout ();
      break;
    }      
    }
  
  public static String getLayoutAsString ()
  {
    switch (layout){
      case EASY_LAYOUT : return "Level 1";
      case MEDIUM_LAYOUT : return "Level 2";
      case HARD_LAYOUT : return "Level 3";
      default :return "Can't be found";
    }  
  }
  
  public void gamerun ()
  {
   
    //moveEngine.start();
//    Thread makeBall = new MakeBall (this);
//    makeBall.start();
    fps = 0;
    int frames = 0;
    long totalTime = 0;
    long curTime = System.currentTimeMillis();
    long lastTime = curTime;
    
    // Start the loop.
    while (isRunning) {
        // Calculations for FPS.
      long beginTimeMillis, timeTakenMillis, timeLeftMillis;
               beginTimeMillis = System.currentTimeMillis();
               
        lastTime = curTime;
        curTime = System.currentTimeMillis();
        totalTime += curTime - lastTime;
        
        if (totalTime > 1000) {
          totalTime -= 1000;
          fps = frames;
          frames = 0;
        }
        ++frames;
        
        if (terminated)
          break;
        if (!paused)
        {
          moveEngine.run();
        }
        else
        {
         pauseGame (); 
        }
        repaint ();
      //repaint the info panel somehow
        //Maybe it doesn't even need to be repainted, just put in static information
        
        //If the player dies
        if (living.get(0).getY() > 590){
          isRunning = false;
        }
        
        timeTakenMillis = System.currentTimeMillis() - beginTimeMillis;
               timeLeftMillis = 1000L / UPDATE_RATE - timeTakenMillis;
               if (timeLeftMillis < 5) timeLeftMillis = 5; // Set a minimum
               
               // Delay and give other thread a chance
               try {
                  Thread.sleep(timeLeftMillis);

               } catch (InterruptedException e) {}
//      } finally {
//        // release resources
//        if (graphics != null) graphics.dispose();
//        if (g2d != null) g2d.dispose();
//      }
        
    }
    System.out.println ("Game Over");
    living.get (0).updatePos (16,16);
    isRunning = true;
    //System.out.println (score);
    
      pause();
   // score = 0;
   // run();
  }

  public void paintComponent (Graphics g)
  {
   super.paintComponent (g);
   g.drawString ("Score: " + Integer.toString (score),70,20);
    //System.out.println ("Print");
   //g2d = (Graphics2D) g;
//   //try{
   for (int i = 0; i < living.size(); i++) {
          /*at = new AffineTransform();
          at.translate(living.get(i).getX(), living.get(i).getY());*/
          //g2d.setColor(Color.BLACK);
          Spawn s = living.get(i);
          g.fillOval ((int)s.getX() - 15,(int)s.getY() - 15,(int)(((CircleSpawn)s).getRadius() * 2),(int)(((CircleSpawn)s).getRadius() * 2));
          //g2d.fill(s.getShape());
        }
   //g2d.setColor (Color.GREEN);
//   for (int x = 0; x < obstacles.size();x++)
//   {
//     Spawn t = obstacles.get(x);
//     g2d.fill (t.getShape());
//   }
   //g.setColor (Color.BLACK);
     for (Paddle p: paddles)
     {     
       g.setColor (p.getColour());
       g.drawLine ((int)p.getX(),(int)p.getY(),(int)p.getX2(),(int)p.getY2());
       //System.out.println (p.toString());
     }
    for (PseudoPaddle p : pseudoPaddles){
      g.drawLine ((int)p.getX(),(int)p.getY(),(int)p.getX2(),(int)p.getY2());}
    for (ObstacleLine l :lines){
      g.drawLine ((int)l.getX(),(int)l.getY(),(int)l.getX2(),(int)l.getY2());}
    for (ButtonObstacle b : buttons){
      g.fillOval ((int)(b.getX() - b.getRadius()),(int)(b.getY() - b.getRadius()),(int)(b.getRadius() * 2),(int)(b.getRadius() * 2));}
//         //display frames per second...
//        g2d.setFont(new Font("Courier New", Font.PLAIN, 12));
        g.drawString(String.format("FPS: %s", fps), 20, 20);
//        
//        
//          //Errors once and then stops. Don't know why it throws a NullPointerException
          if (isPaused())
          {
           g.drawString ("Paused game", 20,40);
          }
        
        if (isRunning == false)
        {
          g.setColor (Color.RED);
          g.drawLine (0,0,400,550);
          g.drawLine (0,550,400,0);
        }
        Toolkit.getDefaultToolkit().sync();
        g.dispose ();
  }
  public static boolean allDead()
  {
    if (living.size() < 1) return true;
    return false;
  }

  public static synchronized int giveBirth(int x, int y, float vx, float vy,int m)
  {
    if (living.size() >= MAX_SPAWN) return 1;
    living.add(new CircleSpawn(x, y, vx, vy,m));
    return 0;
  }
  
  public void pauseThread ()
  {
    /*while (paused)
    {
      try
      {
     Thread.sleep (1);
      }
      catch (InterruptedException e)
      {
        
      }
    }    */
  }
  
  public boolean isPaused ()
  {
   return paused; 
  }
  
  public void pause ()
  {
   paused = true; 
  }
  
 public static boolean open = false;
  public void pauseGame ()
  {
    if (open == false)
    {
     new PauseWindow ();
     open = true;
    }
  }
  public static void increaseScore (int increment)
  {
    score += increment;
  }
  
public int getScore ()
{
  return score;
}

public void resetGame ()
{
  terminated = false;
  score = 0;
}
  public boolean acknowledge = false;
  private ObstacleLine cheat = new ObstacleLine (0,510,400,510,Color.BLACK);
  public void keyPressed (KeyEvent e)
  {
   int key = e.getKeyCode ();
   switch (key){
     case KeyEvent.VK_P : paused = !paused;
     break;
     case KeyEvent.VK_X : 
//For some strange reason the repaint method stops refrshing once this is pressed
       System.out.println ("Pressed");
//       reset ();
//       initialize();
//       living.get (0).updatePos (16,16);
//       isRunning = true;
       //gamerun();
       if (!lines.contains (cheat))
       lines.add (cheat);
       break;
     case KeyEvent.VK_Z :
       lines.remove (cheat);
       break;
     case KeyEvent.VK_ENTER :
       terminated = true;
       
       break;

   }
  }
}


